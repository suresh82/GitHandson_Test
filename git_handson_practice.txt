GIT Commands:

1) git --help
2) git config --system(/--global/--local) <local scope by default)
3) git status
4) git log
5) git init
--> git config --global core.editor "'C:/Program Files (x86)/Notepad++/notepad++.exe' -multiInst -notabbar -nosession -noPlugin"
6) git config -l –local(lists all the local config)

7) git add .
8) git rm --cached <file> ( to get the files to unstage from staging)
9) git ls-files --stage (to check all the files in index/staging)
10) git commit -m "commit message"
11) git remote add orgin "remote url"
12) git push --set-upstream origin master
13) git commit -am "commit message" (add and commit at one go)

14) git clone "remote-url"
15)  git branch -vv [shows us which master branch our brach track to and latest commit message]
16) git branch -l -a [shows all the brances in local repository]
17) git fetch
18) git merge
19) git pull [fetch+merge]

Note: As a remark here, we cannot pull any changes as long as there are modified files in the working directory which would be changed by the commits we are pulling and trying to merge of course. To get the modified files away from the working directory, we can either commit them to the local repository of that branch. Or, if we don't want to commit them yet, we can put them with stashing in a stash in the working directory.

Stashing: When we want to save the current state of changes in the working directory and the index, we can use git stash.

20) git stash
21) git stash list [shows the list of stashes on WIP]
22) git stash pop [would apply the stash and delete it from the list]
23) git stash apply [would apply the stash but does not delete it from the list]

Note: Note here that the stashes acts as a first in, last out process. This means that the latest stash is always on the top of the list

24) git reflog

Branches
25) git branch "branch name"
26) git checkout "branch name"
27) git checkout -b "branch name" [25,26 at one go]

Note: The HEAD is a simple file in the .git directory which points to the active branch and thereby to the latest commit of that branch.
--> The first one is this “FETCH_HEAD” file — this file is a short-lived pointer to keep track of what has just been fetched from the remote repository.
--> Then we have “ORIG_HEAD” pointer file — which saves that previous state of the remote HEAD pointer.


Merging one branch into another-ff merge:
Note: You always merge another branch into the one you have currently set as active, which means checked out branch

A fast-forward merge means that the master branch pointer HEAD can simply be moved forward to the commit where the “MyNewBranch” is pointing to. All this, because the master branch hasn't diverged through other commits on it from the “MyNewBranch”

28) git merge "branch name" [merging the branchname changes onto current active branch-ff merge]
29) git branch -d "branch name" [delete branch]

Merging the Diverged Branches:

This means that in this constellation, the branches have diverged from each other. when you merge such branches, git creates additional commit so-called merge-commit

when you merge.it asks for new commit

Rebase:
This is another way of merging 2 branches. With the concept of rebasing, we get a shiny, clean, and straight forward branch history without Git creating an additional merge commit.

30) git rebase master [It is important to notice here that we rebase onto the current state of the master branch and not into the master branch itself]

Rewritting Commit History
31) git commit -amend

Note: It is important to notice here that when we use --amend, we rewrite the git history of a branch. Most commonly we do this on our own private feature or bug fix branches and not on the main master branch where everyone else is working on or taking their own branches off. it only changes the commit hash and commit message otherwise everything is same.

32) git log --oneline
33) git rebase -i and then followed by the hash value
34) git rebase -i HEAD~3 [3rd commit from where head pointing to]
Note: One important thing to notice when rewriting the history with amending and rebase interactive is that in both cases, new commits with new hashes are created, but the timestamp of creation and the author are taken from the original commits. That is why I have marked these commits with an apostrophe.

Resolving Conflicts:
while merging-->
[when you have merge conflicts, go to the file(s) which has conflicts and remove the unneccessary ones and save it]
35) git merge --abort
while rebasing -->
Once we are done resolving the conflicts while rebasing, we then have to add these changes to the staging area and after that to a git rebase --continue.
There is no need to commit as rebasing does not introduce a merge commit. The conflict will be resolved in the new commit E', created by rebasing.

36) git rebase --continue
37) git rebase --abort
38) git rebase --skip

Cherry Picking, Resetting and Reverting

Cherry Picking:
We might get into the situation one day, where we just want to take some specific changes in a commit from one branch and apply them to another branch. That is exactly what cherry-picking allows us to do, either forcing a commit or a series of commits
Similar to rebase, it will create a new commit, or commits, and put them on the top of a branch.

39) git cherry-pick <commitHash>
